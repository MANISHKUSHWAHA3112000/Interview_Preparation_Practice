                                    /***** Interview Question Set    *****/
                                    
                                    
### Question 1: Can you briefly introduce yourself and highlight your key strengths?  
-->. Hi, my name is Manish Kushwaha. I am a Full Stack Developer with 2 years of experience in building scalable web applications using Java,
 Spring Boot, and Angular. At Capgemini, I developed REST APIs integrating multiple systems, optimized PostgreSQL queries to reduce latency,
and created responsive Angular screens that improved efficiency for shipment tracking and cargo operations. I also streamlined CI/CD workflows with Docker and Kubernetes,
cutting deployment time by 40%. My key strengths are problem-solving, attention to detail, and delivering high-quality solutions under tight deadlines. 
Additionally, I hold certifications in Azure Fundamentals (AZ-900) and Developing Solutions for Microsoft Azure (AZ-204), which strengthen my cloud and DevOps knowledge.
     

Cross-Questions & Answers (Directly After Introduction)
Interviewer: You mentioned scalability â€” can you share a situation where scalability was a challenge and how you solved it?
Answer: In the shipment tracking project, we had performance issues when handling large cargo updates. I optimized PostgreSQL queries by adding proper indexing and restructuring joins, which reduced update latency by 25% and improved scalability for 10K+ records processed daily.

-- Optimized query for shipment tracking with cargo updates
SELECT cu.cargo_id, cu.status, cu.update_date, s.shipment_name
FROM cargo_updates cu
JOIN shipments s ON cu.shipment_id = s.id
WHERE cu.update_date > NOW() - INTERVAL '1 day'
ORDER BY cu.update_date DESC;


Interviewer: How did you streamline CI/CD workflows with Docker and Kubernetes?
Answer: Initially, deployments were manual and time-consuming. I containerized services with Docker, set up Kubernetes for orchestration, and integrated GitHub Actions for automation. This reduced deployment time by 40% and enabled zero-downtime releases.


# Example GitHub Actions workflow
name: CI/CD Pipeline

on:
  push:
    branches: [ "main" ]

jobs:
  build-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build Docker Image
        run: docker build -t myapp:latest .
      - name: Push to Registry
        run: docker push myregistry/myapp:latest
      - name: Deploy to Kubernetes
        run: kubectl apply -f k8s/deployment.yaml


Interviewer: You highlighted improving page load speed by 35% â€” what techniques did you use?
Answer: I implemented Angularâ€™s lazy loading for modules, optimized bundle sizes, and used modular rendering. I measured improvements with Chrome DevTools and Lighthouse, which showed a 35% faster load time.

// app-routing.module.ts
const routes: Routes = [
  { path: 'dashboard', loadChildren: () => import('./dashboard/dashboard.module').then(m => m.DashboardModule) },
  { path: 'reports', loadChildren: () => import('./reports/reports.module').then(m => m.ReportsModule) }
];


Interviewer: How have your Azure certifications helped in real projects?
Answer: My AZ-900 and AZ-204 certifications gave me a strong foundation in cloud services. I applied this knowledge when integrating Azure Event Grid and Service Bus, ensuring real-time communication with 99.9% uptime.

// Example: Publishing event to Azure Event Grid
EventGridPublisherClient client = new EventGridPublisherClient(
    new Uri("https://<topic-name>.eventgrid.azure.net/api/events"),
    new AzureKeyCredential("<access-key>")
);

await client.SendEventAsync(new EventGridEvent(
    subject: "CargoUpdate",
    eventType: "Cargo.StatusChanged",
    dataVersion: "1.0",
    data: new { CargoId = 123, Status = "Delivered" }
));


Interviewer: Can you share an example of a critical issue you solved under tight deadlines?
Answer: During cargo operations, microservices communication was delayed. I analyzed logs, identified bottlenecks, and integrated Azure Service Bus. This resolved the issue quickly and ensured smooth operations before the release deadline.

// Using Azure Service Bus for reliable messaging
@Service
public class CargoMessageService {
    @Autowired
    private ServiceBusSenderClient senderClient;

    public void sendCargoUpdate(String cargoId, String status) {
        ServiceBusMessage message = new ServiceBusMessage(cargoId + ":" + status);
        senderClient.sendMessage(message);
    }
}


Interviewer: What was your biggest contribution in the shipment tracking project?
Answer: My biggest contribution was developing 10+ Angular screens and REST APIs that integrated 5+ systems. This allowed seamless tracking for 500+ users daily and improved operational efficiency significantly.

// Example REST API for shipment tracking
@GetMapping("/shipments/{id}")
public Shipment getShipment(@PathVariable Long id) {
    return shipmentRepository.findById(id)
        .orElseThrow(() -> new ResourceNotFoundException("Shipment not found"));
}


Interviewer: You mentioned role-based access â€” how did you design it effectively?
Answer: I implemented role-based access using Spring Security, defining 5+ user roles across 3 modules. This ensured secure access control while maintaining flexibility for admins, operators, and customers.

@Override
protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
        .antMatchers("/admin/**").hasRole("ADMIN")
        .antMatchers("/operator/**").hasRole("OPERATOR")
        .antMatchers("/customer/**").hasRole("CUSTOMER")
        .anyRequest().authenticated()
        .and().formLogin();
}


### Question 2: What motivates you in your professional career?  
**Answer:** I am motivated by the opportunity to solve complex problems and contribute to impactful projects. Seeing tangible results from my work and collaborating with talented teams inspires me to continuously improve and grow.  

---

### Question 3: How would you describe your approach to problem-solving?  
**Answer:** I take a structured approach to problem-solvingâ€”first analyzing the issue, then researching potential solutions, and finally collaborating with colleagues to implement the most effective strategy.  

---

### Question 4: What are your main career goals, and how do you plan to achieve them?  
**Answer:** My main goal is to advance into leadership roles where I can mentor others and drive innovation. I plan to achieve this through continuous learning, taking on challenging assignments, and building strong professional relationships.  

---

### Question 5: How do you differentiate yourself from other candidates in your field?  
**Answer:** I differentiate myself through my ability to quickly learn new technologies, my strong attention to detail, and my commitment to delivering high-quality work even under tight deadlines.  

---

### Question 6: What values or principles guide your work ethic?  
**Answer:** Integrity, accountability, and continuous improvement guide my work ethic. I believe in taking ownership of tasks and striving for excellence in everything I do.  

---

### Question 7: How do you adapt to new environments or challenges?  
**Answer:** I adapt by being open-minded, proactive in learning, and receptive to feedback. This helps me quickly integrate into new teams and perform effectively in dynamic environments.  

---

### Question 8: Can you share an example where your qualities directly contributed to a successful outcome?  
**Answer:** In my previous role, my adaptability and strong communication skills helped my team deliver a project ahead of schedule. We overcame unexpected challenges through effective collaboration and problem-solving.  

---

### Question 9: How do you leverage your strengths to add value to a team or organization?  
**Answer:** I leverage my strengths by actively contributing to team discussions, sharing knowledge, and supporting colleagues to achieve common goals. This ensures collective success and fosters a collaborative environment.  

---

### Question 10: What is the most important lesson youâ€™ve learned so far in your career?  
**Answer:** The most important lesson Iâ€™ve learned is the value of collaboration and continuous learning. Working together and staying curious leads to better outcomes and long-term personal growth.  


------------------------------------------ Java Interview question  -----------------------------------------------------------------

Question. - How the java internally works?
Java internally works by compiling source code into bytecode, which the JVM loads, verifies, and executes using an interpreter and 
Just-In-Time compiler, while managing memory through garbage collection.

Question - What is Java ?
Java is a High Level object oriented programming language developed by Sun Microsystem in 1995. I t is used for developing the desktop application,web application,android apps and enterprise system.

Question - What is the feature of Java ?

Object-Oriented Programming (OOP): Java supports OOP concepts to create modular and reusable code.
Platform Independence: Java programs can run on any operating system with a JVM.
Robust and Secure: Java ensures reliability and security through strong memory management and exception handling.
Multithreading and Concurrency: Java allows concurrent execution of multiple tasks for efficiency.
Rich API and Standard Libraries: Java provides extensive built-in libraries for various programming needs.
Frameworks for Enterprise and Web Development: Java supports frameworks that simplify enterprise and web application development.
Open-Source Libraries: Java has a wide range of libraries to extend functionality and speed up development.
Maintainability and Scalability: Javaâ€™s structured design allows easy maintenance and growth of applications.

Question - How the Java program run and executed ?
Java  Compiler " javac " compiles it into bytecode "fileName.class".Then JVM reads the .class file and interprets the Bytecode,
JVM convert bytecode to machine readable code ie "binary (000101010) and then executed the program.



       HelloWorld.java  ---->  Java compiler -----> HelloWorld.class 
                                                          |
                                                          | 
        Program                    010101         ------ JVM
        
        
Question - What is the difference between Java, Java 8 ,Java 11 and Java 17 ?

                     Core Java Features
Perfect, Manish â€” Iâ€™ve pulled together **proper definitions** for the features of **Java (core), Java 8, Java 11, and Java 17** based on authoritative sources like GeeksforGeeks, Baeldung, TutorialsPoint, and Tpoint Tech. Letâ€™s go step by step:

---

## ðŸŒ Core Java Features (General)
- **Simple**: Syntax is clean and easy to learn, avoiding complexities like pointers and operator overloading.  
- **Object-Oriented**: Everything is modeled as objects, supporting inheritance, polymorphism, and encapsulation.  
- **Platform Independent**: Compiled into bytecode that runs on any system with JVM â€” â€œWrite Once, Run Anywhere.â€  
- **Portable**: Code can be executed across different platforms without modification.  
- **Secure**: Provides runtime checks, bytecode verification, and restricted access to memory.  
- **Robust**: Strong memory management, exception handling, and type checking.  
- **Multithreaded**: Supports concurrent execution of multiple tasks.  
- **High Performance**: Uses Just-In-Time (JIT) compiler for faster execution.  
- **Distributed**: Supports networking and remote method invocation (RMI).  
- **Dynamic**: Classes are loaded at runtime, allowing flexibility.   

---

## ðŸš€ Java 8 Features (2014)
- **Lambda Expressions**: Enable functional programming by passing behavior as parameters.  
- **Functional Interfaces**: Interfaces with a single abstract method (SAM), used with lambdas.  
- **Stream API**: Provides declarative data processing (filter, map, reduce).  
- **Date and Time API (java.time)**: Modern replacement for `Date` and `Calendar`.  
- **Default & Static Methods in Interfaces**: Allow adding new methods without breaking existing implementations.  
- **Optional Class**: Helps avoid `NullPointerException` by wrapping values.  
- **Nashorn JavaScript Engine**: Execute JavaScript code within JVM.  
- **Collectors & ForEach**: Simplify collection operations.  
- **Parallel Array Sorting**: Improves performance for large datasets.   


## âš¡ Java 11 Features (2018, LTS)
- **Local-Variable Syntax for Lambda Parameters**: Use `var` in lambda expressions for type inference.  
- **HTTP Client API**: Standardized API supporting HTTP/2 and WebSocket.  
- **New String Methods**: `isBlank()`, `lines()`, `strip()`, `repeat()`.  
- **Removed Features**: Applet API, JavaFX bundled, Web Start â€” simplifying the JDK.  
- **Flight Recorder & Mission Control**: Tools for profiling and monitoring applications.  
- **Commercial Licensing Change**: Oracle JDK became paid for commercial use, OpenJDK widely adopted.   

## ðŸ› ï¸ Java 17 Features (2021, LTS)
- **Sealed Classes & Interfaces**: Restrict inheritance to specific classes for better control.  
- **Pattern Matching for `switch` (Preview)**: Simplifies conditional logic with type-safe matching.  
- **Strong Encapsulation of JDK Internals**: Prevents unauthorized access to internal APIs.  
- **InstantSource API**: Provides a new abstraction for time sources.  
- **Deprecations & Removals**: Outdated modules permanently removed.  
- **LTS Support**: Enterprise-grade stability with long-term updates. 

Question - what is the Lambda Expression , with example and coding question in depth ?
A Lambda Expression in Java (introduced in Java 8) is a concise way to represent an anonymous functionâ€”a block of code that can be passed around as data. 
It enables developers to treat functionality as a method argument or assign it to a variable, thereby supporting functional programming within Java.

Formally, a lambda expression provides:

Parameter list: The inputs to the function.

Arrow operator (->): Separates parameters from the body.

Body: The logic or expression to be executed.

@FunctionalInterface
	abstract interface Practice{
		public abstract String findVowel(String s);
	}
	
	Practice p = (s)-> {
			int count=0;
			StringBuilder result = new StringBuilder();
			for(char c : s.toLowerCase().toCharArray()) {
				if("aeiouAEIOU".indexOf(c)!=-1) {
					result.append(Character.toUpperCase(c));
					count++;
				}
				else {
					result.append(c);
				}
			}
			return "Vowel convert into Upper case:  = " + result.toString() + " and  the count of the vowels are :"+count;
		};
		System.out.println(p.findVowel("manish Kushwaha"));
		
Question - Types of Functional Interfaces in Java
Java 8 introduced four main functional interface types under the package java.util.function.These are widely used in Stream API ,collection
and lambda-based operations

Q1. What is a Functional Interface in Java?
A:  
A functional interface is an interface that contains exactly one abstract method.
It is used to represent a single functionality and is the foundation for lambda expressions and method references in Java.

Examples: Runnable, Callable, Comparator, and all interfaces in java.util.function.

Q2. What is the purpose of the @FunctionalInterface annotation?
A:  
@FunctionalInterface is used to explicitly mark an interface as functional.
It ensures the compiler throws an error if more than one abstract method is added accidentally.

Q3. What are the four main types of functional interfaces in Java?
A:  
Java provides four core functional interfaces:

Supplier â€“ produces a value

Consumer â€“ consumes a value

Function â€“ transforms a value

Predicate â€“ tests a condition

These form the base of functional programming in Java.

Q4. What is a Supplier functional interface? Give definition and example.
A:  
Definition:  
Supplier<T> represents a function that takes no input and returns a value.

Abstract method: T get()

Example:

java
Supplier<Double> randomValue = () -> Math.random();
System.out.println(randomValue.get());
Q5. What is a Consumer functional interface? Give definition and example.
A:  
Definition:  
Consumer<T> represents an operation that accepts one input and returns no result.

Abstract method: void accept(T t)

Example:

java
Consumer<String> printer = msg -> System.out.println(msg);
printer.accept("Hello Manish");
Q6. What is a Function functional interface? Give definition and example.
A:  
Definition:  
Function<T, R> represents a function that takes one input and returns one output.

Abstract method: R apply(T t)

Example:

java
Function<String, Integer> lengthFn = str -> str.length();
System.out.println(lengthFn.apply("Java"));
Q7. What is a Predicate functional interface? Give definition and example.
A:  
Definition:  
Predicate<T> represents a function that evaluates a condition and returns a boolean.

Abstract method: boolean test(T t)

Example:

java
Predicate<Integer> isEven = n -> n % 2 == 0;
System.out.println(isEven.test(10)); // true
Q8. What are Bi-functional interfaces?
A:  
Bi-functional interfaces accept two inputs.
Examples include:

BiFunction<T, U, R>

BiConsumer<T, U>

BiPredicate<T, U>

Example:

java
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
System.out.println(add.apply(5, 3));
Q9. What is UnaryOperator?
A:  
Definition:  
UnaryOperator<T> is a specialization of Function<T, T> where input and output types are the same.

Example:

java
UnaryOperator<Integer> square = x -> x * x;
System.out.println(square.apply(4));
Q10. What is BinaryOperator?
A:  
Definition:  
BinaryOperator<T> is a specialization of BiFunction<T, T, T> where both inputs and output are the same type.

Q11. What are primitive functional interfaces? Why do we need them?
A:  
Primitive functional interfaces avoid boxing/unboxing overhead and improve performance.

Examples:

IntPredicate, LongPredicate, DoublePredicate

IntSupplier, LongSupplier, DoubleSupplier

IntFunction<R>, ToIntFunction<T>

Q12. Can a functional interface have default and static methods?
A:  
Yes. A functional interface can have any number of default and static methods, but only one abstract method.

Q13. Can a functional interface extend another interface?
A:  
Yes, as long as the resulting interface still has only one abstract method.

Q14. What happens if you add a second abstract method to a functional interface?
A:  
If @FunctionalInterface is used, the compiler throws an error.
Without the annotation, it compiles but is no longer a functional interface.

Q15. What is the difference between Function and UnaryOperator?
A:

Function<T, R> â†’ input and output may differ

UnaryOperator<T> â†’ input and output are the same (T â†’ T)

Q16. What is the difference between BiFunction and BinaryOperator?
A:

BiFunction<T, U, R> â†’ two inputs, possibly different types

BinaryOperator<T> â†’ two inputs of the same type, returns same type

Q17. Can lambda expressions throw checked exceptions?
A:  
Yes, but only if the functional interface method declares that exception.

Q18. What is the purpose of Predicateâ€™s default methods like and(), or(), negate()?
A:  
They allow logical composition of multiple predicates.

Q19. Why are functional interfaces important for Streams API?
A:  
Streams rely on functional interfaces like Predicate, Function, and Consumer for filtering, mapping, and consuming data.

Q20. Can enums implement functional interfaces?
A:  
Yes. Enums can implement functional interfaces and override the single abstract method.

## 1. Basic Questions

**Q: What is the Java Collection Framework?**  
A: It is a unified architecture for storing and manipulating groups of objects. It provides interfaces (List, Set, Queue, Map) and concrete implementations (ArrayList, HashSet, HashMap, etc.) for efficient data handling.

**Q: What are the main interfaces in the Collection Framework?**  
A: `Collection` (root), `List`, `Set`, `Queue`, and `Map` (though Map is separate from Collection).

**Q: What is the difference between Collection and Collections?**  
A: `Collection` is an interface, while `Collections` is a utility class with static methods like `sort()`, `synchronizedList()`, etc.

**Q: What is the root interface of the Collection hierarchy?**  
A: `Collection` (though `Map` is not a child of Collection).

**Q: What is the difference between List, Set, and Map?**  
A:  
- List â†’ Ordered, allows duplicates.  
- Set â†’ Unordered, no duplicates.  
- Map â†’ Key-value pairs, keys unique.

**Q: What are the differences between ArrayList and LinkedList?**  
A:  
- ArrayList â†’ Backed by array, fast random access, slower insert/delete in middle.  
- LinkedList â†’ Doubly linked list, fast insert/delete, slower random access.

**Q: What is the difference between HashSet and TreeSet?**  
A:  
- HashSet â†’ Unordered, backed by HashMap, faster.  
- TreeSet â†’ Sorted, backed by TreeMap, slower but maintains order.

**Q: What is the difference between HashMap and Hashtable?**  
A:  
- HashMap â†’ Non-synchronized, allows one null key and multiple null values.  
- Hashtable â†’ Synchronized, no null key or values.

**Q: What is the difference between ArrayList and Vector?**  
A:  
- ArrayList â†’ Non-synchronized, modern choice.  
- Vector â†’ Synchronized, legacy class.

**Q: What are the differences between Iterator and ListIterator?**  
A:  
- Iterator â†’ Works for all collections, forward-only.  
- ListIterator â†’ Works only for List, supports bidirectional traversal and element modification.

---

## 2. Intermediate Questions

**Q: How does HashMap work internally?**  
A: It uses an array of buckets + linked list/tree (since Java 8). Hashing determines bucket, collisions handled via chaining or tree.

**Q: Can you store a null key and null values in HashMap?**  
A: Yes, one null key and multiple null values are allowed.

**Q: What is fail-fast and fail-safe Iterator?**  
A:  
- Fail-fast â†’ Throws `ConcurrentModificationException` if structure changes (e.g., ArrayList, HashMap).  
- Fail-safe â†’ Works on a copy, no exception (e.g., ConcurrentHashMap, CopyOnWriteArrayList).

**Q: What is the difference between Comparable and Comparator interfaces?**  
A:  
- Comparable â†’ Natural ordering via `compareTo()`.  
- Comparator â†’ Custom ordering via `compare()`.

**Q: How do you synchronize a Collection?**  
A: Use `Collections.synchronizedList()` or concurrent collections.

**Q: What is ConcurrentHashMap? How is it different from HashMap?**  
A: ConcurrentHashMap is thread-safe, uses fine-grained locking, and disallows null keys/values. HashMap is not thread-safe and allows nulls.

**Q: What is the initial capacity and load factor in HashMap?**  
A: Capacity is the size of the bucket array, load factor is the threshold for resizing (default 0.75).

**Q: What are NavigableMap and NavigableSet?**  
A: Extensions of SortedMap/SortedSet with navigation methods (`lower()`, `higher()`, etc.).

**Q: How does TreeSet ensure elements are sorted?**  
A: By using `compareTo()` or a `Comparator`.

**Q: What is the use of EnumSet and EnumMap?**  
A: Specialized collections for enums, highly efficient.

---

## 3. Advanced/Scenario-Based Questions

**Q: How would you remove duplicates from a List?**  
A: Convert to `Set` or use `stream().distinct()`.

**Q: How does CopyOnWriteArrayList work?**  
A: It creates a copy of the underlying array on modification, making it thread-safe and ideal for read-heavy scenarios.

**Q: Explain the difference between fail-fast and fail-safe iterators with examples.**  
A:  
- Fail-fast: `ArrayList` â†’ modifying while iterating throws exception.  
- Fail-safe: `ConcurrentHashMap` â†’ allows modification during iteration.

**Q: What happens if you add duplicate elements to a Set?**  
A: They are ignored; only unique elements are stored.

**Q: How do you make a Collection read-only?**  
A: Use `Collections.unmodifiableList()` or similar methods.

**Q: Can you modify a Collection while iterating over it?**  
A: Only via `Iterator.remove()`, otherwise `ConcurrentModificationException`.

**Q: What are WeakHashMap and IdentityHashMap?**  
A:  
- WeakHashMap â†’ Keys are weak references, garbage-collected.  
- IdentityHashMap â†’ Keys compared by reference (`==`) not `equals()`.

**Q: What is the difference between Synchronized Collection and Concurrent Collection?**  
A:  
- Synchronized â†’ Wrapper methods, single lock.  
- Concurrent â†’ Fine-grained locking, better performance.

**Q: When would you use LinkedHashMap?**  
A: When insertion order needs to be preserved, e.g., in caches (LRU).

**Q: How do you sort a Collection of custom objects?**  
A: Use `Comparable` or `Comparator`.

---

## 4. Code/Practical Questions

**Q: Write a code to sort a List of custom objects.**  
```java
Collections.sort(list, Comparator.comparing(Employee::getSalary));
```

**Q: Write a code to remove all even numbers from a List using Iterator.**  
```java
Iterator<Integer> it = list.iterator();
while(it.hasNext()) {
    if(it.next() % 2 == 0) it.remove();
}
```

**Q: Write a code to count the frequency of elements in an array using Map.**  
```java
Map<Integer, Integer> freq = new HashMap<>();
for(int num : arr) freq.put(num, freq.getOrDefault(num, 0) + 1);
```

**Q: How do you convert an array to a List and vice versa?**  
```java
List<String> list = Arrays.asList(arr);
String[] arr = list.toArray(new String[0]);
```

**Q: How to find if two Lists are equal?**  
```java
list1.equals(list2); // true if same order & elements
```

---

## 5. Concurrency Questions

**Q: What are concurrent collections? Name some classes.**  
A: Thread-safe collections like `ConcurrentHashMap`, `CopyOnWriteArrayList`, `BlockingQueue`.

**Q: Explain the difference between ConcurrentHashMap and Collections.synchronizedMap().**  
A:  
- ConcurrentHashMap â†’ Fine-grained locking, better scalability.  
- synchronizedMap â†’ Single lock, less efficient.

**Q: What is BlockingQueue?**  
A: A thread-safe queue supporting blocking operations (`put()`, `take()`), useful in producer-consumer scenarios.

**Q: Explain CopyOnWriteArrayList and its use cases.**  
A: Thread-safe list that creates a copy on modification. Best for read-heavy, write-light scenarios.

**Q: How do you handle ConcurrentModificationException?**  
A:  
- Use `Iterator.remove()` instead of modifying directly.  
- Use concurrent collections (e.g., `CopyOnWriteArrayList`, `ConcurrentHashMap`).  
- Or iterate over a snapshot (`new ArrayList<>(list)`).

