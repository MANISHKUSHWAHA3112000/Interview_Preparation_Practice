                                    /***** Interview Question Set    *****/
                                    
                                    
### Question 1: Can you briefly introduce yourself and highlight your key strengths?  
-->. Hi, my name is Manish Kushwaha. I am a Full Stack Developer with 2 years of experience in building scalable web applications using Java,
 Spring Boot, and Angular. At Capgemini, I developed REST APIs integrating multiple systems, optimized PostgreSQL queries to reduce latency,
and created responsive Angular screens that improved efficiency for shipment tracking and cargo operations. I also streamlined CI/CD workflows with Docker and Kubernetes,
cutting deployment time by 40%. My key strengths are problem-solving, attention to detail, and delivering high-quality solutions under tight deadlines. 
Additionally, I hold certifications in Azure Fundamentals (AZ-900) and Developing Solutions for Microsoft Azure (AZ-204), which strengthen my cloud and DevOps knowledge.
     

Cross-Questions & Answers (Directly After Introduction)
Interviewer: You mentioned scalability â€” can you share a situation where scalability was a challenge and how you solved it?
Answer: In the shipment tracking project, we had performance issues when handling large cargo updates. I optimized PostgreSQL queries by adding proper indexing and restructuring joins, which reduced update latency by 25% and improved scalability for 10K+ records processed daily.

-- Optimized query for shipment tracking with cargo updates
SELECT cu.cargo_id, cu.status, cu.update_date, s.shipment_name
FROM cargo_updates cu
JOIN shipments s ON cu.shipment_id = s.id
WHERE cu.update_date > NOW() - INTERVAL '1 day'
ORDER BY cu.update_date DESC;


Interviewer: How did you streamline CI/CD workflows with Docker and Kubernetes?
Answer: Initially, deployments were manual and time-consuming. I containerized services with Docker, set up Kubernetes for orchestration, and integrated GitHub Actions for automation. This reduced deployment time by 40% and enabled zero-downtime releases.


# Example GitHub Actions workflow
name: CI/CD Pipeline

on:
  push:
    branches: [ "main" ]

jobs:
  build-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build Docker Image
        run: docker build -t myapp:latest .
      - name: Push to Registry
        run: docker push myregistry/myapp:latest
      - name: Deploy to Kubernetes
        run: kubectl apply -f k8s/deployment.yaml


Interviewer: You highlighted improving page load speed by 35% â€” what techniques did you use?
Answer: I implemented Angularâ€™s lazy loading for modules, optimized bundle sizes, and used modular rendering. I measured improvements with Chrome DevTools and Lighthouse, which showed a 35% faster load time.

// app-routing.module.ts
const routes: Routes = [
  { path: 'dashboard', loadChildren: () => import('./dashboard/dashboard.module').then(m => m.DashboardModule) },
  { path: 'reports', loadChildren: () => import('./reports/reports.module').then(m => m.ReportsModule) }
];


Interviewer: How have your Azure certifications helped in real projects?
Answer: My AZ-900 and AZ-204 certifications gave me a strong foundation in cloud services. I applied this knowledge when integrating Azure Event Grid and Service Bus, ensuring real-time communication with 99.9% uptime.

// Example: Publishing event to Azure Event Grid
EventGridPublisherClient client = new EventGridPublisherClient(
    new Uri("https://<topic-name>.eventgrid.azure.net/api/events"),
    new AzureKeyCredential("<access-key>")
);

await client.SendEventAsync(new EventGridEvent(
    subject: "CargoUpdate",
    eventType: "Cargo.StatusChanged",
    dataVersion: "1.0",
    data: new { CargoId = 123, Status = "Delivered" }
));


Interviewer: Can you share an example of a critical issue you solved under tight deadlines?
Answer: During cargo operations, microservices communication was delayed. I analyzed logs, identified bottlenecks, and integrated Azure Service Bus. This resolved the issue quickly and ensured smooth operations before the release deadline.

// Using Azure Service Bus for reliable messaging
@Service
public class CargoMessageService {
    @Autowired
    private ServiceBusSenderClient senderClient;

    public void sendCargoUpdate(String cargoId, String status) {
        ServiceBusMessage message = new ServiceBusMessage(cargoId + ":" + status);
        senderClient.sendMessage(message);
    }
}


Interviewer: What was your biggest contribution in the shipment tracking project?
Answer: My biggest contribution was developing 10+ Angular screens and REST APIs that integrated 5+ systems. This allowed seamless tracking for 500+ users daily and improved operational efficiency significantly.

// Example REST API for shipment tracking
@GetMapping("/shipments/{id}")
public Shipment getShipment(@PathVariable Long id) {
    return shipmentRepository.findById(id)
        .orElseThrow(() -> new ResourceNotFoundException("Shipment not found"));
}


Interviewer: You mentioned role-based access â€” how did you design it effectively?
Answer: I implemented role-based access using Spring Security, defining 5+ user roles across 3 modules. This ensured secure access control while maintaining flexibility for admins, operators, and customers.

@Override
protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
        .antMatchers("/admin/**").hasRole("ADMIN")
        .antMatchers("/operator/**").hasRole("OPERATOR")
        .antMatchers("/customer/**").hasRole("CUSTOMER")
        .anyRequest().authenticated()
        .and().formLogin();
}


### Question 2: What motivates you in your professional career?  
**Answer:** I am motivated by the opportunity to solve complex problems and contribute to impactful projects. Seeing tangible results from my work and collaborating with talented teams inspires me to continuously improve and grow.  

---

### Question 3: How would you describe your approach to problem-solving?  
**Answer:** I take a structured approach to problem-solvingâ€”first analyzing the issue, then researching potential solutions, and finally collaborating with colleagues to implement the most effective strategy.  

---

### Question 4: What are your main career goals, and how do you plan to achieve them?  
**Answer:** My main goal is to advance into leadership roles where I can mentor others and drive innovation. I plan to achieve this through continuous learning, taking on challenging assignments, and building strong professional relationships.  

---

### Question 5: How do you differentiate yourself from other candidates in your field?  
**Answer:** I differentiate myself through my ability to quickly learn new technologies, my strong attention to detail, and my commitment to delivering high-quality work even under tight deadlines.  

---

### Question 6: What values or principles guide your work ethic?  
**Answer:** Integrity, accountability, and continuous improvement guide my work ethic. I believe in taking ownership of tasks and striving for excellence in everything I do.  

---

### Question 7: How do you adapt to new environments or challenges?  
**Answer:** I adapt by being open-minded, proactive in learning, and receptive to feedback. This helps me quickly integrate into new teams and perform effectively in dynamic environments.  

---

### Question 8: Can you share an example where your qualities directly contributed to a successful outcome?  
**Answer:** In my previous role, my adaptability and strong communication skills helped my team deliver a project ahead of schedule. We overcame unexpected challenges through effective collaboration and problem-solving.  

---

### Question 9: How do you leverage your strengths to add value to a team or organization?  
**Answer:** I leverage my strengths by actively contributing to team discussions, sharing knowledge, and supporting colleagues to achieve common goals. This ensures collective success and fosters a collaborative environment.  

---

### Question 10: What is the most important lesson youâ€™ve learned so far in your career?  
**Answer:** The most important lesson Iâ€™ve learned is the value of collaboration and continuous learning. Working together and staying curious leads to better outcomes and long-term personal growth.  


------------------------------------------ Java Interview question  -----------------------------------------------------------------

Question. - How the java internally works?
Java internally works by compiling source code into bytecode, which the JVM loads, verifies, and executes using an interpreter and 
Just-In-Time compiler, while managing memory through garbage collection.

Question - What is Java ?
Java is a High Level object oriented programming language developed by Sun Microsystem in 1995. I t is used for developing the desktop application,web application,android apps and enterprise system.

Question - What is the feature of Java ?

Object-Oriented Programming (OOP): Java supports OOP concepts to create modular and reusable code.
Platform Independence: Java programs can run on any operating system with a JVM.
Robust and Secure: Java ensures reliability and security through strong memory management and exception handling.
Multithreading and Concurrency: Java allows concurrent execution of multiple tasks for efficiency.
Rich API and Standard Libraries: Java provides extensive built-in libraries for various programming needs.
Frameworks for Enterprise and Web Development: Java supports frameworks that simplify enterprise and web application development.
Open-Source Libraries: Java has a wide range of libraries to extend functionality and speed up development.
Maintainability and Scalability: Javaâ€™s structured design allows easy maintenance and growth of applications.

Question - How the Java program run and executed ?
Java  Compiler " javac " compiles it into bytecode "fileName.class".Then JVM reads the .class file and interprets the Bytecode,
JVM convert bytecode to machine readable code ie "binary (000101010) and then executed the program.



       HelloWorld.java  ---->  Java compiler -----> HelloWorld.class 
                                                          |
                                                          | 
        Program                    010101         ------ JVM
        
Question-. Is Java Platform Independent? If yes, how?
Yes, Java is a platform-independent language. Unlike many programming languages, the Java compiler (javac) compiles a program into bytecode (a .class file). 
This bytecode is not tied to any specific hardware or operating system but requires a Java Virtual Machine (JVM) to execute.
Although the JVM itself is platform-dependent.

Question -Difference between JVM, JRE and JDK.
JVM: JVM also known as Java Virtual Machine is a part of JRE. JVM is a type of interpreter responsible for converting bytecode into machine-readable code. JVM itself is platform dependent 
but it interprets the bytecode which is the platform-independent reason why Java is platform-independent. 
JRE: JRE stands for Java Runtime Environment, it is an installation package that provides an environment to run the Java program or application on any machine.
JDK: JDK stands for Java Development Kit which provides the environment to develop and execute Java programs.

Question-What are Memory storages available with JVM?

JVM consists of a few memory storages as mentioned below:

Class(Method) Area: stores class-level data of every class such as the runtime constant pool, field, and method data, and the code for methods.
Heap: Objects are created or objects are stored. It is used to allocate memory to objects during run time.
Stack: stores data and partial results which will be needed while returning value for method and performing dynamic linking
Program Counter Register: stores the address of the Java virtual machine instruction currently being executed.
Native Method Stack: stores all the native methods used in the application.

Question-What will happen if we donâ€™t declare the main method as static?
The main method in Java is declared as public static void main(String[] args) because the JVM needs to call it without creating an object.
If the main method is not static, it becomes an instance method, and the JVM cannot call it directly since no object exists at the start of execution.
The code will compile successfully, but at runtime, the JVM will throw an error like:

Question- Why is Java not 100% Object-Oriented?
Because it contains primitive data types (int, boolean, char, etc.) which are not objects

Question - What is Java String Pool?
A Java String Pool is a place in heap memory where all the strings defined in the program are stored.
 A separate place in a stack is there where the variable storing the string is stored. Whenever we create a new string object, 
 JVM checks for the presence of the object in the String pool, If String is available in the pool, the same object reference is shared with the variable, 
 else a new object is created.
        
Question - Where is `"abc"` stored when we write `String s = "abc";`?
**A:** It is stored in the **String Constant Pool (SCP)** inside the heap. If `"abc"` already exists, Java reuses the same reference.


### Q2: Where is `"abc"` stored when we write `String s = new String("abc");`?
**A:** A **new String object** is created in the heap, even though `"abc"` also exists in the SCP. So you end up with two objects: one in SCP and one in heap.

### Q3: What happens if we compare two string literals?

String s1 = "abc";
String s2 = "abc";
```
**A:**  
- `s1 == s2` â†’ **true** (same SCP reference)  
- `s1.equals(s2)` â†’ **true** (same content)


### Q4: What happens if we compare a literal with `new String("abc")`?

String s1 = "abc";
String s3 = new String("abc");
```
**A:**  
- `s1 == s3` â†’ **false** (different references: SCP vs heap)  
- `s1.equals(s3)` â†’ **true** (same content)


### Q5: What will `System.out.println` show?
**A:** Both print `"abc"` because `toString()` of a String returns its content.

### Q6: What is the difference between `==` and `.equals()` in Strings?
**A:**  
- `==` â†’ compares **references** (memory addresses).  
- `.equals()` â†’ compares **values** (characters inside the string).

### Q7: Can we make `new String("abc")` point to SCP?
**A:** Yes, by using `.intern()`:
```java
String s3 = new String("abc").intern();
```
Now `s3` will point to the SCP object, so `s1 == s3` â†’ **true**.

Question-What is the Wrapper class in Java?
A Wrapper Class in Java is a class that wraps (encapsulates) a primitive data type into an object. 
Since Java is object-oriented, wrapper classes allow primitives to be used where objects are required, 
like in Collections (ArrayList, HashMap, etc.).

Primitive	Wrapper Class
byte	Byte
short	Short
int	Integer
long	Long
float	Float
double	Double
char	Character
boolean	Boolean

Question - Why do we need wrapper classes?
The wrapper class is an object class that encapsulates the primitive data types, and we need them for the following reasons:

Wrapper classes are final and immutable
Provides methods like valueOf(), parseInt(), etc.
It provides the feature of autoboxing and unboxing.

What is autoboxing and unboxing?
Autoboxing: Autoboxing is the automatic conversion of a primitive type to its corresponding wrapper class object.
Unboxing: Autoboxing and unboxing reduce boilerplate code. Can happen implicitly in expressions, assignments, and method calls.

Question- What is a String in Java?
A String is an object in Java that represents a sequence of characters. Strings are immutable, meaning once created, their value cannot be changed.

String s = "Hello";

Question-What does it mean that Strings are immutable?
Once a String object is created, it cannot be modified. Any operation that seems to modify a String creates a new String object.

String s1 = "Hello";
String s2 = s1.concat(" World"); // s1 remains "Hello"

Question-What are the differences between StringBuffer and StringBuilder?

             StringBuffer                                                                               StringBuilder
StringBuffer provides functionality to work with the strings.	                        StringBuilder is a class used to build a mutable string.
It is thread-safe (two threads can't call the methods of StringBuffer simultaneously)	It is not thread-safe (two threads can call the methods concurrently)
Comparatively slow as it is synchronized.	                                            Being non-synchronized, implementation is faster


Question-How to copy an array in Java?
In Java, there are multiple ways to copy an array based on the requirements:

1. clone() Method (Shallow Copy)

The clone() method creates a new array with its own memory but contains references to the same objects for non-primitive data types.
For primitive arrays, it behaves like a deep copy since primitive values are directly copied.
int[] arr = {1, 2, 3, 5, 0};
int[] tempArr = arr.clone(); // Creates a new array with copied values

2. System.arraycopy() Method (Deep Copy)

This method creates a new array and copies elements from the original array.
It allows partial copying by specifying an offset and length.
int[] arr = {1, 2, 7, 9, 8};
int[] tempArr = new int[arr.length];
System.arraycopy(arr, 0, tempArr, 0, arr.length);

3. Arrays.copyOf() Method (Creates New Array)

This method creates a new array and copies the entire original array into it.
If the specified length is greater than the original array, extra elements are initialized with default values.
int[] arr = {1, 2, 4, 8};
int[] tempArr = Arrays.copyOf(arr, arr.length);


Question-What is an object-oriented paradigm and What are the main concepts of OOP in Java?
The object-oriented paradigm is based on using objects as the main entities. These objects can use features like encapsulation, inheritance, and polymorphism to build structured programs.

Question-What are Classes in Java? 
In Java, Classes are the collection of objects sharing similar characteristics and attributes. Classes represent the blueprint or template from which objects are created.  Classes are not real-world entities but help us to create objects which are real-world entities. A class is declared using the class keyword. and It contains:

Fields / Variables (data of an object)
Methods (operations/functions)
Constructors
Nested classes
Blocks (static & instance)

Question- What is an object?
The object is a real-life entity that has certain properties and methods associated with it. The object is also defined as the instance of a class. An object can be declared using a new keyword.

Question-What are the different ways to create objects in Java?
Methods to create objects in Java are mentioned below:

Using new keyword
Using new instance
Using clone() method
Using deserialization
Using the newInstance() method of the Constructor class

Question- What is this keyword in Java?
â€˜thisâ€™ is a keyword used to reference a variable that refers to the current object.

Question-What are Access Specifiers and Types of Access Specifiers?

Access Specifiers in Java help to restrict the scope of a class, constructor, variable, method, or data member. There are four types of Access Specifiers in Java mentioned below:

Public
Private
Protected
Default

---------------------------- ----------- - -- ---- Core Java Features--------------------------------------------

Question - What is the difference between Java, Java 8 ,Java 11 and Java 17 ?

## ðŸŒ Core Java Features (General)
- **Simple**: Syntax is clean and easy to learn, avoiding complexities like pointers and operator overloading.  
- **Object-Oriented**: Everything is modeled as objects, supporting inheritance, polymorphism, and encapsulation.  
- **Platform Independent**: Compiled into bytecode that runs on any system with JVM â€” â€œWrite Once, Run Anywhere.â€  
- **Portable**: Code can be executed across different platforms without modification.  
- **Secure**: Provides runtime checks, bytecode verification, and restricted access to memory.  
- **Robust**: Strong memory management, exception handling, and type checking.  
- **Multithreaded**: Supports concurrent execution of multiple tasks.  
- **High Performance**: Uses Just-In-Time (JIT) compiler for faster execution.  
- **Distributed**: Supports networking and remote method invocation (RMI).  
- **Dynamic**: Classes are loaded at runtime, allowing flexibility.   

---

## ðŸš€ Java 8 Features (2014)
- **Lambda Expressions**: Enable functional programming by passing behavior as parameters.  
- **Functional Interfaces**: Interfaces with a single abstract method (SAM), used with lambdas.  
- **Stream API**: Provides declarative data processing (filter, map, reduce).  
- **Date and Time API (java.time)**: Modern replacement for `Date` and `Calendar`.  
- **Default & Static Methods in Interfaces**: Allow adding new methods without breaking existing implementations.  
- **Optional Class**: Helps avoid `NullPointerException` by wrapping values.  
- **Nashorn JavaScript Engine**: Execute JavaScript code within JVM.  
- **Collectors & ForEach**: Simplify collection operations.  
- **Parallel Array Sorting**: Improves performance for large datasets.   


## âš¡ Java 11 Features (2018, LTS)
- **Local-Variable Syntax for Lambda Parameters**: Use `var` in lambda expressions for type inference.  
- **HTTP Client API**: Standardized API supporting HTTP/2 and WebSocket.  
- **New String Methods**: `isBlank()`, `lines()`, `strip()`, `repeat()`.  
- **Removed Features**: Applet API, JavaFX bundled, Web Start â€” simplifying the JDK.  
- **Flight Recorder & Mission Control**: Tools for profiling and monitoring applications.  
- **Commercial Licensing Change**: Oracle JDK became paid for commercial use, OpenJDK widely adopted.   

## ðŸ› ï¸ Java 17 Features (2021, LTS)
- **Sealed Classes & Interfaces**: Restrict inheritance to specific classes for better control.  
- **Pattern Matching for `switch` (Preview)**: Simplifies conditional logic with type-safe matching.  
- **Strong Encapsulation of JDK Internals**: Prevents unauthorized access to internal APIs.  
- **InstantSource API**: Provides a new abstraction for time sources.  
- **Deprecations & Removals**: Outdated modules permanently removed.  
- **LTS Support**: Enterprise-grade stability with long-term updates. 

Question - what is the Lambda Expression , with example and coding question in depth ?
A Lambda Expression in Java (introduced in Java 8) is a concise way to represent an anonymous functionâ€”a block of code that can be passed around as data. 
It enables developers to treat functionality as a method argument or assign it to a variable, thereby supporting functional programming within Java.

Formally, a lambda expression provides:

Parameter list: The inputs to the function.

Arrow operator (->): Separates parameters from the body.

Body: The logic or expression to be executed.

@FunctionalInterface
	abstract interface Practice{
		public abstract String findVowel(String s);
	}
	
	Practice p = (s)-> {
			int count=0;
			StringBuilder result = new StringBuilder();
			for(char c : s.toLowerCase().toCharArray()) {
				if("aeiouAEIOU".indexOf(c)!=-1) {
					result.append(Character.toUpperCase(c));
					count++;
				}
				else {
					result.append(c);
				}
			}
			return "Vowel convert into Upper case:  = " + result.toString() + " and  the count of the vowels are :"+count;
		};
		System.out.println(p.findVowel("manish Kushwaha"));
		
Question - Types of Functional Interfaces in Java
Java 8 introduced four main functional interface types under the package java.util.function.These are widely used in Stream API ,collection
and lambda-based operations : Consumer, Predicate, Function,supplier

Q1. What is a Functional Interface in Java?
A:  
A functional interface is an interface that contains exactly one abstract method.
It is used to represent a single functionality and is the foundation for lambda expressions and method references in Java.

Examples: Runnable, Callable, Comparator, and all interfaces in java.util.function.

Q2. What is the purpose of the @FunctionalInterface annotation?
A:  
@FunctionalInterface is used to explicitly mark an interface as functional.
It ensures the compiler throws an error if more than one abstract method is added accidentally.

Q3. What are the four main types of functional interfaces in Java?
A:  
Java provides four core functional interfaces:

Supplier â€“ produces a value

Consumer â€“ consumes a value

Function â€“ transforms a value

Predicate â€“ tests a condition

These form the base of functional programming in Java.

Q4. What is a Supplier functional interface? Give definition and example.
A:  
Definition:  
Supplier<T> represents a function that takes no input and returns a value.

Abstract method: T get()

Example:

java
Supplier<Double> randomValue = () -> Math.random();
System.out.println(randomValue.get());
Q5. What is a Consumer functional interface? Give definition and example.
A:  
Definition:  
Consumer<T> represents an operation that accepts one input and returns no result.

Abstract method: void accept(T t)

Example:

java
Consumer<String> printer = msg -> System.out.println(msg);
printer.accept("Hello Manish");
Q6. What is a Function functional interface? Give definition and example.
A:  
Definition:  
Function<T, R> represents a function that takes one input and returns one output.

Abstract method: R apply(T t)

Example:

java
Function<String, Integer> lengthFn = str -> str.length();
System.out.println(lengthFn.apply("Java"));
Q7. What is a Predicate functional interface? Give definition and example.
A:  
Definition:  
Predicate<T> represents a function that evaluates a condition and returns a boolean.

Abstract method: boolean test(T t)

Example:

java
Predicate<Integer> isEven = n -> n % 2 == 0;
System.out.println(isEven.test(10)); // true
Q8. What are Bi-functional interfaces?
A:  
Bi-functional interfaces accept two inputs.
Examples include:

BiFunction<T, U, R>

BiConsumer<T, U>

BiPredicate<T, U>

Example:

java
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
System.out.println(add.apply(5, 3));
Q9. What is UnaryOperator?
A:  
Definition:  
UnaryOperator<T> is a specialization of Function<T, T> where input and output types are the same.

Example:

java
UnaryOperator<Integer> square = x -> x * x;
System.out.println(square.apply(4));
Q10. What is BinaryOperator?
A:  
Definition:  
BinaryOperator<T> is a specialization of BiFunction<T, T, T> where both inputs and output are the same type.

Q11. What are primitive functional interfaces? Why do we need them?
A:  
Primitive functional interfaces avoid boxing/unboxing overhead and improve performance.

Examples:

IntPredicate, LongPredicate, DoublePredicate

IntSupplier, LongSupplier, DoubleSupplier

IntFunction<R>, ToIntFunction<T>

Q12. Can a functional interface have default and static methods?
A:  
Yes. A functional interface can have any number of default and static methods, but only one abstract method.

Q13. Can a functional interface extend another interface?
A:  
Yes, as long as the resulting interface still has only one abstract method.

Q14. What happens if you add a second abstract method to a functional interface?
A:  
If @FunctionalInterface is used, the compiler throws an error.
Without the annotation, it compiles but is no longer a functional interface.

Q15. What is the difference between Function and UnaryOperator?
A:

Function<T, R> â†’ input and output may differ

UnaryOperator<T> â†’ input and output are the same (T â†’ T)

Q16. What is the difference between BiFunction and BinaryOperator?
A:

BiFunction<T, U, R> â†’ two inputs, possibly different types

BinaryOperator<T> â†’ two inputs of the same type, returns same type

Q17. Can lambda expressions throw checked exceptions?
A:  
Yes, but only if the functional interface method declares that exception.

Q18. What is the purpose of Predicateâ€™s default methods like and(), or(), negate()?
A:  
They allow logical composition of multiple predicates.

Q19. Why are functional interfaces important for Streams API?
A:  
Streams rely on functional interfaces like Predicate, Function, and Consumer for filtering, mapping, and consuming data.

Q20. Can enums implement functional interfaces?
A:  
Yes. Enums can implement functional interfaces and override the single abstract method.

## 1. Basic Questions

**Q: What is the Java Collection Framework?**  
A: It is a unified architecture for storing and manipulating groups of objects. It provides interfaces (List, Set, Queue, Map) and concrete implementations (ArrayList, HashSet, HashMap, etc.) for efficient data handling.

**Q: What are the main interfaces in the Collection Framework?**  
A: `Collection` (root), `List`, `Set`, `Queue`, and `Map` (though Map is separate from Collection).

**Q: What is the difference between Collection and Collections?**  
A: `Collection` is an interface, while `Collections` is a utility class with static methods like `sort()`, `synchronizedList()`, etc.

**Q: What is the root interface of the Collection hierarchy?**  
A: `Collection` (though `Map` is not a child of Collection).

**Q: What is the difference between List, Set, and Map?**  
A:  
- List â†’ Ordered, allows duplicates.  
- Set â†’ Unordered, no duplicates.  
- Map â†’ Key-value pairs, keys unique.

**Q: What are the differences between ArrayList and LinkedList?**  
A:  
- ArrayList â†’ Backed by array, fast random access, slower insert/delete in middle.  
- LinkedList â†’ Doubly linked list, fast insert/delete, slower random access.

**Q: What is the difference between HashSet and TreeSet?**  
A:  
- HashSet â†’ Unordered, backed by HashMap, faster.  
- TreeSet â†’ Sorted, backed by TreeMap, slower but maintains order.

**Q: What is the difference between HashMap and Hashtable?**  
A:  
- HashMap â†’ Non-synchronized, allows one null key and multiple null values.  
- Hashtable â†’ Synchronized, no null key or values.

**Q: What is the difference between ArrayList and Vector?**  
A:  
- ArrayList â†’ Non-synchronized, modern choice.  
- Vector â†’ Synchronized, legacy class.

**Q: What are the differences between Iterator and ListIterator?**  
A:  
- Iterator â†’ Works for all collections, forward-only.  
- ListIterator â†’ Works only for List, supports bidirectional traversal and element modification.

---

## 2. Intermediate Questions

**Q: How does HashMap work internally?**  
A: It uses an array of buckets + linked list/tree (since Java 8). Hashing determines bucket, collisions handled via chaining or tree.

**Q: Can you store a null key and null values in HashMap?**  
A: Yes, one null key and multiple null values are allowed.

**Q: What is fail-fast and fail-safe Iterator?**  
A:  
- Fail-fast â†’ Throws `ConcurrentModificationException` if structure changes (e.g., ArrayList, HashMap).  
- Fail-safe â†’ Works on a copy, no exception (e.g., ConcurrentHashMap, CopyOnWriteArrayList).

**Q: What is the difference between Comparable and Comparator interfaces?**  
A:  
- Comparable â†’ Natural ordering via `compareTo()`.  
- Comparator â†’ Custom ordering via `compare()`.

**Q: How do you synchronize a Collection?**  
A: Use `Collections.synchronizedList()` or concurrent collections.

**Q: What is ConcurrentHashMap? How is it different from HashMap?**  
A: ConcurrentHashMap is thread-safe, uses fine-grained locking, and disallows null keys/values. HashMap is not thread-safe and allows nulls.

**Q: What is the initial capacity and load factor in HashMap?**  
A: Capacity is the size of the bucket array, load factor is the threshold for resizing (default 0.75).

**Q: What are NavigableMap and NavigableSet?**  
A: Extensions of SortedMap/SortedSet with navigation methods (`lower()`, `higher()`, etc.).

**Q: How does TreeSet ensure elements are sorted?**  
A: By using `compareTo()` or a `Comparator`.

**Q: What is the use of EnumSet and EnumMap?**  
A: Specialized collections for enums, highly efficient.

---

## 3. Advanced/Scenario-Based Questions

**Q: How would you remove duplicates from a List?**  
A: Convert to `Set` or use `stream().distinct()`.

**Q: How does CopyOnWriteArrayList work?**  
A: It creates a copy of the underlying array on modification, making it thread-safe and ideal for read-heavy scenarios.

**Q: Explain the difference between fail-fast and fail-safe iterators with examples.**  
A:  
- Fail-fast: `ArrayList` â†’ modifying while iterating throws exception.  
- Fail-safe: `ConcurrentHashMap` â†’ allows modification during iteration.

**Q: What happens if you add duplicate elements to a Set?**  
A: They are ignored; only unique elements are stored.

**Q: How do you make a Collection read-only?**  
A: Use `Collections.unmodifiableList()` or similar methods.

**Q: Can you modify a Collection while iterating over it?**  
A: Only via `Iterator.remove()`, otherwise `ConcurrentModificationException`.

**Q: What are WeakHashMap and IdentityHashMap?**  
A:  
- WeakHashMap â†’ Keys are weak references, garbage-collected.  
- IdentityHashMap â†’ Keys compared by reference (`==`) not `equals()`.

**Q: What is the difference between Synchronized Collection and Concurrent Collection?**  
A:  
- Synchronized â†’ Wrapper methods, single lock.  
- Concurrent â†’ Fine-grained locking, better performance.

**Q: When would you use LinkedHashMap?**  
A: When insertion order needs to be preserved, e.g., in caches (LRU).

**Q: How do you sort a Collection of custom objects?**  
A: Use `Comparable` or `Comparator`.

---

## 4. Code/Practical Questions

**Q: Write a code to sort a List of custom objects.**  
```java
Collections.sort(list, Comparator.comparing(Employee::getSalary));
```

**Q: Write a code to remove all even numbers from a List using Iterator.**  
```java
Iterator<Integer> it = list.iterator();
while(it.hasNext()) {
    if(it.next() % 2 == 0) it.remove();
}
```

**Q: Write a code to count the frequency of elements in an array using Map.**  
```java
Map<Integer, Integer> freq = new HashMap<>();
for(int num : arr) freq.put(num, freq.getOrDefault(num, 0) + 1);
```

**Q: How do you convert an array to a List and vice versa?**  
```java
List<String> list = Arrays.asList(arr);
String[] arr = list.toArray(new String[0]);
```

**Q: How to find if two Lists are equal?**  
```java
list1.equals(list2); // true if same order & elements
```

---

## 5. Concurrency Questions

**Q: What are concurrent collections? Name some classes.**  
A: Thread-safe collections like `ConcurrentHashMap`, `CopyOnWriteArrayList`, `BlockingQueue`.

**Q: Explain the difference between ConcurrentHashMap and Collections.synchronizedMap().**  
A:  
- ConcurrentHashMap â†’ Fine-grained locking, better scalability.  
- synchronizedMap â†’ Single lock, less efficient.

**Q: What is BlockingQueue?**  
A: A thread-safe queue supporting blocking operations (`put()`, `take()`), useful in producer-consumer scenarios.

**Q: Explain CopyOnWriteArrayList and its use cases.**  
A: Thread-safe list that creates a copy on modification. Best for read-heavy, write-light scenarios.

**Q: How do you handle ConcurrentModificationException?**  
A:  
- Use `Iterator.remove()` instead of modifying directly.  
- Use concurrent collections (e.g., `CopyOnWriteArrayList`, `ConcurrentHashMap`).  
- Or iterate over a snapshot (`new ArrayList<>(list)`).

